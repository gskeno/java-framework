# MVCC是什么？
- 英文名称 Multi-Version Concurrency Control 多版本并发控制。
- 背景知识说明: 一个事务在**真正**开启前，会去向系统申请一个事务id(**trx_id**),这个事务id是全局递增的。而真正开启事务，创建一致性视图
  (**Read View**)是在执行事务语句内的第一条select快照图语句时。<br><br>
  
  当然你可以通过`start transaction with consistent snapshot`开启事务
  并同时创建一致性视图，这时事务id和一致性视图是一起出来的。如下图所示

 ![mvcc1](png/mvcc1.png)

# MVCC实现说明
- **视图数组，高水位，低水位**，这些都是核心关键词。一个事务在开启的时候(创建一致性视图的时候)，会将当前系统中
正在进行中(活跃)的事务id保存到一个数组中，这个数组就是视图数组。<br><br>
  
  这个数组的最小值就是**低水位**，而开始事务时，系统中已生成的事务id的最大值+1就是**高水位**，_这里要注意到
  系统中已生成的事务id最大值并不一定就是视图数组的最大值，因为后生成的事务id可能先提交。_ <br><br>
 
  行数据都是存在**版本**性质的，这个版本就是数据产生时相关联的事务id。当前事务中，它拥有一个视图数组，低高
  水位，同时，它还能"触及"到目标行数据的当前数据(带版本号)，行数据是由一个版本号链串起来的，当前视图应该看到
  哪个版本号下的数据，正是由MVCC定义的。 <br><br>
  
  如果行数据版本不小于视图数组高水位，说明看到的行数据是在当前事务创建之后生成的，**不应该可见**。比如，当前事务
  创建后下一秒生成了一个新事务，且新事务update后提交很快，当前事务还没有提交这种情况。<br><br>

  如果行数据版本小于视图数组低水位，说明看到的行数据是在当前事务创建之前生成的，**应该可见**。<br><br>

  如果行数据版本在视图数组低水位到高水位之间，但不在视图数组中。说明看到的行数据是在当前事务创建之前生成的，**应该可见**。
  只不过事务id比数组最小值大或者比高水位小而已，就好像是当前事务id前几个事务id后者后几个事务id，开启事务后
  提交很快，当前事务开启时，这些事务都提交了。<br><br>

  如果行数据版本在视图数组低水位到高水位之间，且视图数组中。说明这个数据版本是由开启当前事务时还没提交的事务生成的，
  _**应该不可见**_

# 可重复读隔离级别下(mysql默认隔离级别)和读提交隔离级别下，mvcc的表现有什么不同？
- 可重复读时，是在事务真正开启时(start transaction时是在第一条select语句时，事务才真正开启, start transaction with 
consistent snapshot 是在执行完这条语句时事务就真正开启)，创建一个一致性读视图，整个过程中不再改变。<br><br>
- 读提交，是在执行每一条语句时，都重建创建一个一致性读视图(Read View), **这会导致在两种隔离级别下看到的有效数据版本不一致**。

# 事务未提交时，事务内部更新的数据有效吗？
- 有效，事务未提交前，如果执行了update语句，影响到的行数据版本号就生成了，**数据版本号链 + 一致性视图**，就会影响事务内部应该看到
哪个版本下的数据。
  
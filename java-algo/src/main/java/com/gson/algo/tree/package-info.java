/**
 *
 * <p1>广度优先遍历 {@link com.gson.algo.tree.CBTInserter}</p1>
 * <ul>
 *     <li>
 *         完全二叉树广度优先遍历，即按照树的层级从顶层逐级向下层，同时从左向右遍历。<br>
 *         使用队列，首先将跟节点push进队列。 <br>
 *         每次从队列取出头部节点，同时将该节点的左右孩子节点依次push进队列。 <br>
 *         队列中可能会存在包含两层节点的情况。
 *     </li>
 *
 *     <li>
 *         如何确定每层的最左节点、最右侧节点、最大节点呢？<br>
 *         有两种方式<br>
 *         1. 使用两个计数器，记录遍历的当前层节点数目cur和下一层节点数目next。
 *           当前层每遍历到一个节点时,cur--, 该节点每有一个孩子，则push进队列，同时next++。
 *           当cur为0时，表示当前层节点全部遍历完毕，要进入到下一层进行遍历。next赋值给cur,
 *           同时0赋值给next <br>
 *         2. 使用两个队列，一个队列记录当前层遍历的节点，一个队列记录下一层要遍历的节点。
 *            每遍历当前层级的一个节点时，将其中当前层对应的队列中移出，并将其孩子放入下一层对应的队列中。
 *            当前层队列为空后，将下一层队列赋值给当前层队列，将空队列赋值给下一层队列
 *     </li>
 * </ul>
 *
 * <p>
 *     ----------------------------------------------------------
 * </p>
 *
 * <p1>深度优先遍历</p1>
 * <ul>
 *     <li>中序遍历 {@link com.gson.algo.tree.DFSSearchTree}, 可以使用递归和栈两种方式</li>
 *     <li>前序遍历</li>
 *     <li>后序遍历，可以使用递归和栈，但栈的使用有两种，可以用一个栈，也可以用两个栈</li>
 * </ul>
 * <p>
 *     ----------------------------------------------------------
 * </p>
 * <ul>
 *     <li>深度优先遍历一般适用于解决与路径有关的树问题</li>
 * </ul>
 *
 * <p>
 *     -----------------------------------------------------------
 * </p>
 * <ul>
 *     <li>二叉搜索树，左子节点小于等于父节点，右子结点大于等于父节点，中序遍历结果就是节点从小到大排列的结果</li>
 *     <li>二叉搜索树，左子树的节点都小于等于根节点，右子树的节点都大于等于根节点</li>
 * </ul>
 *
 */
package com.gson.algo.tree;
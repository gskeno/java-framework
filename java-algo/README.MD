# 双指针
- [四数之和](https://leetcode.cn/problems/4sum/)
> 1.最后两个数的选取可以使用双指针，降低时间复杂度。

> 2.可以进行"剪枝"，跳过不必要的遍历。

> 3.可能出现数值溢出，将int转化为long。


# 广度优先搜索
- [机器人的运动范围](https://leetcode.cn/problems/ji-qi-ren-de-yun-dong-fan-wei-lcof/)
> 1. 走过的路径需要标记，防止重复计数，一般使用一个同规格二维数组辅助解决。

- [01 矩阵](https://leetcode.cn/problems/01-matrix/)
> 题目：给定一个由 0 和 1 组成的矩阵 mat，请输出一个大小相同的矩阵，其中每一个格子是 mat 中对应位置元素到最近的 0 的距离。 两个相邻元素间的距离为 1 。

> 分析:广度优先搜索，首先把所有0元素的坐标放进队列，再设置一个二维访问标记数组visit[][]和输出结果grid[][]。
> 从队列头部移出元素(坐标)，遍历该坐标上下左右4个位置，设置gird[x+dx][y+dy] = grid[x][y], 且将(x+dx, y+dy)坐标也放进队列。


## 总结
- 广度优先搜索的经典场景一般都是迷宫，矩阵问题，在做决策时，往往会有多个选择。
- 广度优先搜索一般使用队列来处理，如果需要识别已经搜索过的位置，还需要使用辅助数组visit，在遍历过程中
已经访问过的路径需要忽略掉。

# 记忆化搜索
- [为运算表达式设计优先级](https://leetcode.cn/problems/different-ways-to-add-parentheses/)
```
题目: 输入：expression = "2*3-4*5"
输出：[-34,-14,-10,-10,10]
解释：
(2*(3-(4*5))) = -34
((2*3)-(4*5)) = -14
((2*(3-4))*5) = -10
(2*((3-4)*5)) = -10
(((2*3)-4)*5) = 10
```

> 1. 自顶向下计算，使用递归

> 2. 递归过程中已经计算过的结果要存储起来，会被重复用到，需要使用一个数组保存计算结果。

> 3. dp[left][right]表示expression[left]到expression[right]组成的子表达式subExpression的所有可能的运算结果。
> 则subExpression的左右边界是数字，内部夹杂着数字和运算符。以其中任意一个运算符作为分割点，则
> 分割点左部分表达式的运算结果集合 _**组合上**_ 右部分表达式的元素结果集合。这个组合的意思就是`_**加，减，乘**_`操作

> 4. 类似的题目还有 [面试题 08.14. 布尔运算](https://leetcode.cn/problems/boolean-evaluation-lcci/)

# 动态规划
- [变换的迷宫(困难)](https://leetcode.cn/problems/Db3wC1/)
> 1. 多维矩阵(3维及以上)
> 2. 解决该问题涉及到的知识点很多，有动态规划，深度优先搜索，广度优先搜索，状态机等。


